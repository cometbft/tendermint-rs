**Preparation for high-level English spec for new architecture** 



# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The light client implements a read operation of a
[header][TMBC-HEADER-link] from the [blockchain][TMBC-SEQ-link], by
communicating with full nodes.  As some full nodes may be faulty, this
functionality must be implemented in a fault-tolerant way.

For the purpose of this specification, we assume that the blockchain
 is a list of headers, rather than a list of blocks, by
 [**[TMBC-HEADER]**][TMBC-HEADER-link].

In the Tendermint blockchain, the validator set may change with every
new block.  The staking and unbonding mechanism induces a [security
model][TMBC-FM-2THIRDS-link]: starting at time *Time* of the
[header][TMBC-HEADER-link],
more than two-thirds of the next validators of a new block are correct
for the duration of *TrustedPeriod*. The fault-tolerant read
operation is designed for this security model.

The challenge addressed here is that the light client might have a
block of height *h1* and needs to read the block of height *h2*
greater than *h1*.  Checking all headers of heights from *h1* to *h2*
might be too costly (e.g., in terms of energy for mobile devices).
This specification tries to reduce the number of intermediate blocks
that need to be checked, by exploiting the guarantees provided by the
[security model][TMBC-FM-2THIRDS-link].



# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the light client verification component, called *Verifier*.
The *Verifier* communicates with a full node. 
As full nodes may be faulty, the light client has to check whether
the header it receives coincides with the one generated by Tendermint consensus. 
The central features used in this specification are:

 - Tendermint blockchain ensures several [soundness properties][blockchain]
   [TMBC-SOUND-?]. If a block does not satisfy this soundness
   properties it did not originate from the blockchain. Verification
   encodes these tests,

 - the Tendermint [security model][TMBC-FM-2THIRDS-link] guarantees that there is a set of full 
 nodes that represent more than two-thirds of the voting power in the *NextValidators* set, such that the full nodes in this set are correct from 
 the time a block is generated until the trusting period has passed.


 To do verification checks based on these properties, the two 
 properties [[TMBC-VAL-CONTAINS-CORR]][TMBC-VAL-CONTAINS-CORR-link] and
[[TMBC-VAL-COMMIT]][TMBC-VAL-COMMIT-link]  formalize the checks done
 by this specification:
Given a trusted block *tb* and an untrusted block *ub* with a commit *cub*,
one has to check that *cub* is in *PossibleCommit(ub)*, and that *cub*
contains a correct node using *tb*.


## Informal Problem statement


Given a height *h* as an input, the *Verifier* stores a header of
height *h* locally.  This header is generated by the Tendermint
[blockchain][blockchain]. In particular, a header that violates one of
the [soundness properties][blockchain] [TMBC-SOUND-?] should never be
stored.


## Sequential Problem statement

#### **[LCV-Seq-Live]**: 
The *Verifier* gets as input a height *h*, and eventually stores the
header of height *h* of the blockchain, that is, *chain[h]* [**[TMBC-SEQ]**][TMBC-SEQ-link].

#### **[LCV-Seq-Inv]**:
The *Verifier* never stores a header which is not in the blockchain.


# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

The light client *Verifier* communicates with a full node of a Tendermint blockchain. 
Full nodes satisfy the following properties:
[**[TMBC-CorrFull]**][TMBC-CorrFull-link], 
 and [**[TMBC-Auth-Byz]**][TMBC-Auth-Byz-link].

### Incentives

Faulty full nodes may benefit from lying to the light client, by making the
light client accept a block that deviates (e.g., contains additional 
transactions) from the one generated by Tendermint consensus. 
Users using the light client might be harmed by accepting a forged header.

The [fork detector][failuredetector] of the light client may help the correct full nodes to understand whether their header is a good one. 
Hence, in combination with the light client detector, the correct full nodes have the incentive to respond.
We can thus base liveness arguments on the assumption that correct full nodes reliably talk to the light client.



### Assumptions

#### **[LCV-A-FULL]**:
The verifier communicates with a full node. No assumption is made about the full node (it may be correct or faulty).

#### **[LCV-A-Comm]**:
Communication between the light client and a correct full node is
reliable and bounded in time. Reliable communication means that
messages are not lost, not duplicated, and eventually delivered. There
is a (known) end-to-end delay *Delta*, such that if a message is sent
at time *t* then it is received and processes by time *t + Delta*.

#### **[LCV-A-TFM]**:
The Tendermint blockchain satisfies the Tendermint failure model [**[TMBC-FM-2THIRDS]**][TMBC-FM-2THIRDS-link].

<!---
#### **[LCV-A-LCC]**:
The light client is following the protocol (it is correct).
-->


## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

#### **[LCV-D-State]**:
The light client has a local data structure called *State* that
contains headers.  
**TODO:** make consistent with detector

#### **[LCV-D-Primary]**:
The light client has a local variable *primary* that contains the Address (ID) of a full node.

#### **[LCV-D-State-Init]**:
State is initialized with *inithead* that was correctly generated by the Tendermint consensus.

### Temporal Properties

#### **[LCV-VC-Inv]**:
It is always the case that every header in *State* was generated by an instance of Tendermint consensus.

#### **[LCV-VC-Live]**:
From time to time, a new instance of the verifier is called with a height *h*. Each instance must eventually terminate. The instance adds a header *hd* with height *h* to *State* if

  - the full node (peer) with which the verifier communicates is correct
  - *State* contains a header whose age is less than the trusting period.

*Remark*: These definitions imply that if the peer is faulty, a header may or may not be added to *State*. In any case, [**[LCV-VC-Inv]**](#lcv-vc-inv) must hold.

*Remark*: The invariant [**[LCV-VC-Inv]**](#lcv-vc-inv) and the liveness requirement [**[LCV-VC-Live]**](#lcv-vc-live)
allow that headers are added to *State* whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

*Remark*: In liveness [**[LCV-VC-Live]**](#lcv-vc-live) we use "eventually", while in practice
the header *hd* should be added to *State* before the *trustingPeriod* expires, starting from *hd.Time*.

### Solving the sequential specification

This specification provides a partial solution to the sequential specification.
The *Verifier* solves the invariant of the sequential part

[**[LCV-VC-Inv]**](#lcv-vc-inv) => [**[LCV-Seq-Inv]**](#lcv-seq-inv)

In the case the peer is correct, and there is a recent header in *State*, the verifier satisfies the liveness requirements.

/\ "correct peer"  
/\ \E TrustedState in State. TrustedState.SignedHeader.Header.Time >
now - *trustingPeriod*  
/\ [**[LCV-A-Comm]**](#lcv-a-comm) /\
       [**[TMBC-CorrFull]**][TMBC-CorrFull-link] /\
       [**[LCV-VC-Live]**](#lcv-vc-live)  
       => [**[LCV-Seq-Live]**](#lcv-seq-live)


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

> We now introduce variables and auxiliary functions used by the protocol.

### Data Types

```go
type SignedHeader struct {
    Header        Header
    Commit        Commit       
}
```

```
type VerificationHeader struct {
	signedHeader SignedHeader
    Validators  ValidatorSet
    NextValidators ValidatorSet
}
```	
cf. [TMBC-VALIDATOR-Set]



### Inputs
- *trustedHeader*: the Verification Header verification starts from
- *peer*: peer address
- *targetHeight*:

#### **[LCV-A-INIT]**:
- *trustedHeader.signedHeader* is from the blockchain
- *targetHeight > trustedHeader.height*

### Configuration Parameters

- *trustThreshold*: a float. Can be used if correctness should not be based on more voting power and 1/3.
- *trustingPeriod*: a time duration [**[TMBC-TIME_PARAMS]**][TMBC-TIME_PARAMS-link].
- *clockDrift*: a time duration. Correction parameter dealing with only approximately synchronized clocks.


### Variables

- *height*: initially *trustedHeader.Height*
- *nextHeight*: initially *targetHeight*
> *nextHeight* should be thought of the "height of the next header we need
to download and verify"
- *trustedStore*: stores verification headers that have been downloaded and that
    passed verification. Initially it only contains *startBlock*:
> Something like this was called *State* in ADR. Should be made
>    consistent 
>	with detector. We should decide what it contains: e.g., (i) set of headers,
> (ii) set of TrustedState (iii) set of pairs: Trustedstate, address of
> full node from which the lightlient downloaded the header   
- *headerToVerify*: a verification header. Initially nil	
   - written by IO
- *Error*: error information. Initially nil.




### Auxiliary Functions

#### **[LCV-FUNC-REF]**:
- *refHeader*: is the header from *trustedStore* with the maximal
  height
  
  

**TODO:** messages
  
  
### Algorithm Invariants

### **[LCV-INV-VAL]**
At all times
- *headerToVerify.Validators = hash(headerToVerify.signedHeader.Header.Validators)*
- *headerToVerify.NextValidators = hash(headerToVerify.signedHeader.Header.NextValidators)*


  
### Remote Functions
  ```go
func Commit(addr Address, height int64) (SignedHeader, error)
```
- Implementation remark
   - RPC to full node *n*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns the signed header of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns a signed header with arbitrary content
- Error condition
   * if *n* is correct: precondition violated or timeout
   * if *n* is faulty: arbitrary error

----


 ```go    
func Validators(addr Address, height int64) (ValidatorSet, error)
```
- Implementation remark
   - RPC to full node *n*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns the validator set of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns arbitrary validator set
- Error condition
  - if *n* is correct: precondition violated or timeout 
  - if *n* is faulty: arbitrary error

----

## Core Verification

### Outline

The protocols is described in terms of the following functions.

- `getHeaderData` is called to do IO, that is, 
  download the next header, and validator sets
- `VerifyBisection` calls `verifySingle` to see whether a new header can
  be trusted. If not, it does bisection by updating the nextheight
  variable
- `verifySingle` checks a new header based on the most recently trusted
  header
  

In the current Rust architecture we consider a sequential flow, that
is, execution of a loop where first `getHeaderData` and then
`VerifyBisection` are invoked (`VerifyBisection` calls `verifySingle`).



#### **[LCV-TERM-EXPIRED]**
If *refHeader.signedHeader.header.time < now - trustingPeriod* 
set *Error = EXPIRED* and **terminate with failure**.

#### **[LCV-TERM-SUCCESS]**
If *Height = targetHeight* then **terminate successfully**


### Details



**TODO:** synchronous algorithm?

```go
func getHeaderData
```
-  Implementation remark
   - Used to communicate with a full node *n* at address *addr* via 
     RPCs `Commit` and `Validators` 
   - The only function that makes external calls!
   - This function make externals RPC calls to the full node; 
      - `Validators(nextHeight)`
	  - `Validators(nextHeight+1)` 
	  - `Commit (nextHeight)`
   
- Expected precondition
  - *nextheight > refHeader.signedHeader.Header.Height*
- Expected postcondition: 
  - If *n* is correct, it returns the following data:
c    - *headerToVerify.signedHeader* is a signed header consistent with
      the blockchain
    - *headerToVerify.Validators* is the validator set of the
      blockchain at height *nextheight*
    - *headerToVerify.NextValidators* is the validator set of the
      blockchain at height *nextheight + 1*
    - *headerToVerify.signedHeader.Header.Time < now + clockDrift*
  - If *n* is faulty, returns arbitrary 
  - [LCV-INV-VAL] (if *n* is faulty or not)
- Error conditions
  - precondition violated
  - If the field time of the returned signed header is greater than or
    equal to `now + clockDrift`, then set *error = InvalidHeaderTime*
    and **terminate with failure**.
  - If *n* is faulty

---


```go
func VerifyBisection {
    err := VerifySingle(trustedHeader, headerToVerify)
    if err == OK {
      height = nextHeight
	  nextHeight = targetHeight
    } else if err = CANNOT_VERIFY{
      compute pivot // (height + nextHeight) / 2
      nextHeight = pivot
    }
  }
}
```
- Expected precondition
  - none
- Expected postcondition
  - *nextHeight <= targetHeight*
  - *nextHeight > height*
- Error conditions 
  - IF `VerifySingle` returns a error code *code* different from OK or
  CANNOT_VERIFY then set *error = code*
    and **terminate with failure**.
---


```go
func VerifySingle(untrustedVh VerificationHeader,
                  trustedVh VerificationHeader) (error)
```

- Expected precondition:
   - the `height` and `Time` of `trustedVh` are smaller than the height and 
  `Time` of `untrustedVh`, respectively
   - the *SignedHeader* satisfies the soundness requirements
     [**[TMBC-SOUND-?]**][blockchain], in particular
      - if the untrusted signed header `unstrustedVh` is the immediate 
	  successor  of  `trustedVh`, then it holds that
	      - *trustedVh.NextValidators = untrustedVh.Validators*, and
		  moreover, 
		  - more than two-thirds of the validators signed
- Expected postcondition: 
    - Returns `OK` if:
        - *untrustedVh* is the immediate successor of *trustedVh*, or
        - *untrustedVh* is the successor of *trustedVh*, 
		   - and a set of
             validators that have more than *max(1/3,trustThreshold)* of
             voting power in *trustedVh*  signed *untrustedVh*
           - and header passes the tests [TMBC-VAL-CONTAINS-CORR] and [TMBC-VAL-COMMIT]
	- Returns `CANNOT_VERIFY` if
	[**[TMBC-VAL-CONTAINS-CORR]**][TMBC-VAL-CONTAINS-CORR-link] 
	fails and header is does not violate the soundness
checks [**[TMBC-SOUND-?]**][blockchain].
- Error condition: 
   - precondition violated

---











# References

[[block]] Specification of the block data structure. 

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to this specification are labeled [TMBC-*].

[[failuredetector]] The specification of the light client fork detector.

[[fullnode]] Specification of the full node API

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md
[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md
[TMBC-HEADER-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-header
[TMBC-SEQ-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-seq
[TMBC-CorrFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-corrfull
[TMBC-Auth-Byz-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-auth-byz
[TMBC-Sign-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sign
[TMBC-FaultyFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-faultyfull
[TMBC-TIME_PARAMS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-time_params
[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-fm-2thirds
[TMBC-VAL-CONTAINS-CORR-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-contains-corr
[TMBC-VAL-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-commit
[TMBC-SOUND-DISTR-LAST-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-last-commit
[TMBC-SOUND-DISTR-PossCommit-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-posscommit


[TMBC-INV-SIGN-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-sign
[TMBC-INV-VALID-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-valid

[LCV-VC-LIVE-link]: https://github.com/informalsystems/VDD/tree/master/lightclient/verification.md#lcv-vc-live

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md
[failuredetector]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md
[fullnode]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md

[FN-LuckyCase-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-luckycase

[blockchain-validator-set]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md#data-structures
[fullnode-data-structures]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#data-structures

[FN-ManifestFaulty-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-manifestfaulty
