**Preparation for high-level English spec for new architecture** 



# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The light client implements a read operation of a
[header][TMBC-HEADER-link] from the [blockchain][TMBC-SEQ-link], by
communicating with full nodes.  As some full nodes may be faulty, this
functionality must be implemented in a fault-tolerant way.

For the purpose of this specification, we assume that the blockchain
 is a list of headers, rather than a list of blocks, by
 [**[TMBC-HEADER]**][TMBC-HEADER-link].

In the Tendermint blockchain, the validator set may change with every
new block.  The staking and unbonding mechanism induces a [security
model][TMBC-FM-2THIRDS-link]: starting at time *Time* of the
[header][TMBC-HEADER-link],
more than two-thirds of the next validators of a new block are correct
for the duration of *TrustedPeriod*. The fault-tolerant read
operation is designed for this security model.

The challenge addressed here is that the light client might have a
block of height *h1* and needs to read the block of height *h2*
greater than *h1*.  Checking all headers of heights from *h1* to *h2*
might be too costly (e.g., in terms of energy for mobile devices).
This specification tries to reduce the number of intermediate blocks
that need to be checked, by exploiting the guarantees provided by the
[security model][TMBC-FM-2THIRDS-link].



# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the light client verification component, called *Verifier*.
The *Verifier* communicates with a full node. 
As full nodes may be faulty, the light client has to check whether
the header it receives coincides with the one generated by Tendermint consensus. 
The central features used in this specification are:

 - Tendermint blockchain ensures several [soundness properties][blockchain]
   [TMBC-SOUND-?]. If a block does not satisfy this soundness
   properties it did not originate from the blockchain. Verification
   encodes these tests,

 - the Tendermint [security model][TMBC-FM-2THIRDS-link] guarantees that there is a set of full 
 nodes that represent more than two-thirds of the voting power in the *NextValidators* set, such that the full nodes in this set are correct from 
 the time a block is generated until the trusting period has passed.


 To do verification checks based on these properties, the two 
 properties [[TMBC-VAL-CONTAINS-CORR]][TMBC-VAL-CONTAINS-CORR-link] and
[[TMBC-VAL-COMMIT]][TMBC-VAL-COMMIT-link]  formalize the checks done
 by this specification:
Given a trusted block *tb* and an untrusted block *ub* with a commit *cub*,
one has to check that *cub* is in *PossibleCommit(ub)*, and that *cub*
contains a correct node using *tb*.


## Informal Problem statement


Given a height *h* as an input, the *Verifier* stores a header of
height *h* locally.  This header is generated by the Tendermint
[blockchain][blockchain]. In particular, a header that violates one of
the [soundness properties][blockchain] [TMBC-SOUND-?] should never be
stored.


## Sequential Problem statement

#### **[LCV-Seq-Live]**: 
The *Verifier* gets as input a height *h*, and eventually stores the
header of height *h* of the blockchain, that is, *chain[h]* [**[TMBC-SEQ]**][TMBC-SEQ-link].

#### **[LCV-Seq-Inv]**:
The *Verifier* never stores a header which is not in the blockchain.


# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

The light client *Verifier* communicates with a full node of a Tendermint blockchain. 
Full nodes satisfy the following properties:
[**[TMBC-CorrFull]**][TMBC-CorrFull-link], 
 and [**[TMBC-Auth-Byz]**][TMBC-Auth-Byz-link].

### Incentives

Faulty full nodes may benefit from lying to the light client, by making the
light client accept a block that deviates (e.g., contains additional 
transactions) from the one generated by Tendermint consensus. 
Users using the light client might be harmed by accepting a forged header.

The [fork detector][failuredetector] of the light client may help the correct full nodes to understand whether their header is a good one. 
Hence, in combination with the light client detector, the correct full nodes have the incentive to respond.
We can thus base liveness arguments on the assumption that correct full nodes reliably talk to the light client.



### Assumptions

#### **[LCV-A-FULL]**:
The verifier communicates with a full node. No assumption is made about the full node (it may be correct or faulty).

#### **[LCV-A-Comm]**:
Communication between the light client and a correct full node is
reliable and bounded in time. Reliable communication means that
messages are not lost, not duplicated, and eventually delivered. There
is a (known) end-to-end delay *Delta*, such that if a message is sent
at time *t* then it is received and processes by time *t + Delta*.

#### **[LCV-A-TFM]**:
The Tendermint blockchain satisfies the Tendermint failure model [**[TMBC-FM-2THIRDS]**][TMBC-FM-2THIRDS-link].

<!---
#### **[LCV-A-LCC]**:
The light client is following the protocol (it is correct).
-->


## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

#### **[LCV-D-State]**:
The light client has a local data structure called *State* that
contains headers.  
**TODO:** make consistent with detector

#### **[LCV-D-Primary]**:
The light client has a local variable *primary* that contains the Address (ID) of a full node.

#### **[LCV-D-State-Init]**:
State is initialized with *inithead* that was correctly generated by the Tendermint consensus.

### Temporal Properties

#### **[LCV-VC-Inv]**:
It is always the case that every header in *State* was generated by an instance of Tendermint consensus.

#### **[LCV-VC-Live]**:
From time to time, a new instance of the verifier is called with a height *h*. Each instance must eventually terminate. The instance adds a header *hd* with height *h* to *State* if

  - the full node (peer) with which the verifier communicates is correct
  - *State* contains a header whose age is less than the trusting period.

*Remark*: These definitions imply that if the peer is faulty, a header may or may not be added to *State*. In any case, [**[LCV-VC-Inv]**](#lcv-vc-inv) must hold.

*Remark*: The invariant [**[LCV-VC-Inv]**](#lcv-vc-inv) and the liveness requirement [**[LCV-VC-Live]**](#lcv-vc-live)
allow that headers are added to *State* whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

*Remark*: In liveness [**[LCV-VC-Live]**](#lcv-vc-live) we use "eventually", while in practice
the header *hd* should be added to *State* before the *trustingPeriod* expires, starting from *hd.Time*.

### Solving the sequential specification

This specification provides a partial solution to the sequential specification.
The *Verifier* solves the invariant of the sequential part

[**[LCV-VC-Inv]**](#lcv-vc-inv) => [**[LCV-Seq-Inv]**](#lcv-seq-inv)

In the case the peer is correct, and there is a recent header in *State*, the verifier satisfies the liveness requirements.

/\ "correct peer"  
/\ \E TrustedState in State. TrustedState.SignedHeader.Header.Time >
now - *trustingPeriod*  
/\ [**[LCV-A-Comm]**](#lcv-a-comm) /\
       [**[TMBC-CorrFull]**][TMBC-CorrFull-link] /\
       [**[LCV-VC-Live]**](#lcv-vc-live)  
       => [**[LCV-Seq-Live]**](#lcv-seq-live)


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

> We now introduce variables and auxiliary functions used by the protocol.

### Data Types

```go
type SignedHeader struct {
    Header        Header
    Commit        Commit       
}
```

```
type VerificationHeader struct {
	signedHeader SignedHeader
    Validators  ValidatorSet
    NextValidators ValidatorSet
}
```	
cf. [TMBC-VALIDATOR-Set]



### Inputs
- *trustedHeader*: the VerificationHeader verification starts from
- *peer*: peer address
- *targetHeight*:

#### **[LCV-A-INIT]**:
- *trustedHeader.signedHeader* is from the blockchain
- *targetHeight > trustedHeader.height*

### Configuration Parameters

- *trustThreshold*: a float. Can be used if correctness should not be based on more voting power and 1/3.
- *trustingPeriod*: a time duration [**[TMBC-TIME_PARAMS]**][TMBC-TIME_PARAMS-link].
- *clockDrift*: a time duration. Correction parameter dealing with only approximately synchronized clocks.


### Variables

*height*: initially *trustedHeader.Height*
*nextHeight*: initially *targetHeight*
> *nextHeight* should be thought of the "height of the next header we need
to download and verify"
- *trustedStore*: stores verification headers that have been downloaded and that
    passed verification. Initially it only contains *startBlock*:
> Something like this was called *State* in ADR. Should be made
>    consistent 
>	with detector. We should decide what it contains: e.g., (i) set of headers,
> (ii) set of TrustedState (iii) set of pairs: Trustedstate, address of
> full node from which the lightlient downloaded the header   
- *headerToVerify*: a verification header. Initially nil	
   - written by IO

### **[LCV-INV-VAL]**
At all times
- *headerToVerify.Validators = hash(headerToVerify.signedHeader.Header.Validators)*
- *headerToVerify.NextValidators = hash(headerToVerify.signedHeader.Header.NextValidators)*




### Auxiliary Functions

#### **[LCV-FUNC-REF]**:
- *refHeader*: is the header from *trustedStore* with the maximal
  height
  
**TODO:** messages
  
### Remote Functions
  ```go
func Commit(height int64) (SignedHeader, error)
```
- Implementation remark
   - RPC to full node *n*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns the signed header of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns a signed header with arbitrary content
- Error condition
   * if *n* is correct: precondition violated or timeout
   * if *n* is faulty: arbitrary error

----


 ```go    
func Validators(height int64) (ValidatorSet, error)
```
- Implementation remark
   - RPC to full node *n*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns the validator set of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns arbitrary validator set
- Error condition
  - if *n* is correct: precondition violated or timeout 
  - if *n* is faulty: arbitrary error

----

## Core Verification

### Outline

- init checks time
- IO is called to download the next header
- OutputResult returns


```go
func IO
```
- Implementation remarks:
     - This function make externals RPC calls to the full node; 
	 Validators(nextHeight), Validators(nextHeight+1), Commit (nextHeight)
- Expected precondition:
   - headerToVerify is nil or headerToVerify.Height < nextHeight
- Expected postcondition:
   - **TODO** *headerToVerify* is the header retured by *peer* for height *height*
   - *headerToVerify.Validators = hash(headerToVerify.signedHeader.Header.Validators)*
   - *headerToVerify.NextValidators = hash(headerToVerify.signedHeader.Header.NextValidators)*
- Error condition
   - if postcondition is violated (peer faulty)





```go
func Init
```
checks time




```go
func VerifyBisection {
    err := VerifySingle(trustedHeader, headerToVerify)
    if err == OK {
      height = nextHeight
	  nextHeight = targetHeight
    } else if err = CANNOT_VERIFY{
      compute pivot // (height + nextHeight) / 2
      nextHeight = pivot
    }
  }
}
```
- Expected precondition
  - the field `Time` of the signed header of `trustedState` is within *trustingPeriod* from `now`
- Expected postcondition
  - Returns a trusted state whose header is the header at height `untrustedHeight` from the blockchain, if [**[FN-LuckyCase]**][FN-LuckyCase-link] holds, and if the field `Time` of the header of the returned trusted state is greater than `now + clockDrift`     
- Error conditions 
  - violated precondition 
  - [**[FN-LuckyCase]**][FN-LuckyCase-link] does not hold
  - the header lies in the future  
  **TODO:** What is the precise
    condition about the future?

---


```go
func VerifySingle(untrustedVh VerificationHeader,
                  trustedVh VerificationHeader) (TrustedState, error)
```

- Implementation remarks:
     - This function does not make external RPC calls to the full node; the whole logic is
based on the local (given) state. 
- Expected precondition:
   - the field `Time` of the untrusted signed header `untrustedSh` is greater than `now + clockDrift` 
   - the signed header of the trusted state was generated within the *trustingPeriod*
   - the height and `Time` of the signed header of the trusted state are smaller than the height and 
  `Time` of the untrusted signed header `untrustedSh`, respectively
   - the *SignedHeader* satisfies the soundness requirements
     [**[TMBC-SOUND-?]**][blockchain], in particular
      - the untrusted signed header `untrustedSh` and the untrusted validator sets `untrustedVs`, 
  `untrustedNextVs` are consistent
      - if the untrusted signed header `unstrustedSh` is the immediate successor of 
  the signed header of the trusted state `trustedState`, then it holds that 
  the next validator set of the signed header of the `trustedState` is equal to the untrusted 
  validator set `untrustedVs`, and moreover, more than two-thirds of the validators 
  signed
- Expected postcondition: 
    - Returns `(trustedState, OK)` if:
        - the untrusted signed header `untrustedSh` is the immediate successor of the signed header
    of the trusted state `trustedState`  [TMBC-SOUND-?], or
        - the untrusted signed header `untrustedSh` is a successor of
        the signed header of the trusted state `trustedState` and the
        validators that have more than *max(1/3,trustThreshold)* of
        voting power in the trusted state `trustedState` signed the
        untrusted signed header `untrustedSh` 
		header passes the tests [TMBC-VAL-CONTAINS-CORR] and [TMBC-VAL-COMMIT]
	- Returns `(trustedState, CANNOT_VERIFY)` if
	[**[TMBC-VAL-CONTAINS-CORR]**][TMBC-VAL-CONTAINS-CORR-link] 
	fails and header is does not violate the soundness
checks [**[TMBC-SOUND-?]**][blockchain].
- Error condition: 
   - precondition violated
   - the untrusted signed header `untrustedSh` is not a successor of the signed header of the trusted state `trustedState`

---



```go
func OutputResult
```
- Implementation remark
  - *Time* is the local time when the function is scheduled
- Expected precondition
  - *ref-Header.Height = targetHeight* OR **some error**
- Expected postcondition: 
  - Returns `(trustedStore, OK)`
     if the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated within *trustingPeriod* from *endTime*
  - Returns `(trustedStore, EXPIRED)` under [**[FN-LuckyCase]**][FN-LuckyCase-link], if
  the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated after *endTime - trustingPeriod* 





#### **[LCV-QueryFullNode]**:

`QueryFullNode` is called by `VerifyBisection`, and it is used to gather information from a
full node at address `addr`.
```go
func QueryFullNode(addr Address, 
                  untrustedHeight int64) 
                  (SignedHeader,  ValidatorSet, ValidatorSet, error)
```
-  Implementation remark
   - Used to communicate with a full node *n* at address *addr* via RPCs `Commit` and `Validators` 
   - The only function that makes external calls!
   - in order to ensure [**[FN-LuckyCase]**][FN-LuckyCase-link] the
     timeout for the RPCs must be greater than or equal to *2 Delta*, cf.
	 [**[LCV-A-Comm]**](#lcv-a-comm).
- Expected precondition
  - true
- Expected postcondition: 
  - If *n* is correct and there is no error in the RPC to *n*: Returns the following data:
    - `SignedHeader` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight + 1` 
  - The field time of the returned signed header is smaller than `now + clockDrift`
- Error conditions
  - precondition violated
  - The field time of the returned signed header is greater than or
    equal to `now + clockDrift`
  - If *n* is faulty or there is an error in the RPC to *n*

*Remark*: Observe that the error conditions includes "error in RPC to *n*" but
*not* [**[FN-LuckyCase]**][FN-LuckyCase-link].
A faulty peer might return arbitrary values, without
forcing the function to report an error.

---

If `QueryFullNode` returns without error, `VerifyBisection` calls `VerifySingle`.





# References

[[block]] Specification of the block data structure. 

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to this specification are labeled [TMBC-*].

[[failuredetector]] The specification of the light client fork detector.

[[fullnode]] Specification of the full node API

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md
[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md
[TMBC-HEADER-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-header
[TMBC-SEQ-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-seq
[TMBC-CorrFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-corrfull
[TMBC-Auth-Byz-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-auth-byz
[TMBC-Sign-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sign
[TMBC-FaultyFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-faultyfull
[TMBC-TIME_PARAMS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-time_params
[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-fm-2thirds
[TMBC-VAL-CONTAINS-CORR-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-contains-corr
[TMBC-VAL-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-commit
[TMBC-SOUND-DISTR-LAST-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-last-commit
[TMBC-SOUND-DISTR-PossCommit-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-posscommit


[TMBC-INV-SIGN-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-sign
[TMBC-INV-VALID-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-valid

[LCV-VC-LIVE-link]: https://github.com/informalsystems/VDD/tree/master/lightclient/verification.md#lcv-vc-live

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md
[failuredetector]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md
[fullnode]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md

[FN-LuckyCase-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-luckycase

[blockchain-validator-set]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md#data-structures
[fullnode-data-structures]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#data-structures

[FN-ManifestFaulty-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-manifestfaulty
