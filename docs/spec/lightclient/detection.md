***This is the beginning of an unfinished draft. Comments are welcome!***

# Fork detector

A detector (or detector for short) is a mechanism that expects as
input a header with some height *h*, connects to different Tendermint
full nodes, requests the header of height *h* from them, and then
cross-checks the headers and the input header.

There are two foreseeable use cases:

1) strengthen the light client: If a light client accepts a header
*hd* (after performing skipping or sequential verification), it can
use the  detector to probe the system for conflicting headers and
increase the trust in *hd*. Instead of communicating with a single
full node, communicating with several full nodes shall increase the
likelihood to be aware of a fork (see [[accountability]] for
discussion about forks) in case there is one.

2) to support fork accountability: In the case when more than 1/3 of
the voting power is held by faulty validators, faulty nodes may
generate two conflicting headers for the same height. The goal of the
detector is to learn about the conflicting headers by probing
different full nodes. Once a detector has two conflicting headers,
these headers are evidence of misbehavior. A natural extension is to
use the detector within a monitor process (on a full node) that calls
the detector on a sample (or all) headers (in parallel). (If the
sample is chosen at random, this adds a level of probabilistic
reasoning.) If conflicting headers are found, they are evidence that
can be used for punishing processes.

In this document we will focus onn strengthening the light client, and
leave other uses of the detection mechanism (e.g., when run on a full
node) to the future.


## Context of this document

The light client verification specification [[verification]] is
designed for the Tendermint failure model (1/3 assumption)
[TMBC-FM-2THIRDS]. It is safe under this assumption, and live
if it can reliably (that is, no message loss, no duplication, and
eventually delivered) and timely communicate with a correct full node. If
this assumption is violated, the light client can be fooled to trust a
header that was not generated by Tendermint consensus.

This specification, the fork detector, is a "second line of defense",
in case the 1/3 assumption is violated. Its goal is to collect
evidence. However, it is impractical to probe all full nodes. At this
time we consider a simple scheme of maintaining an address book of
known full nodes from which a small subset (e.g., 4) are chosen
initially to communicate with. More involved book keeping with
probabilistic guarantees can be considered at later stages of the
project.

The light client maintains a simple address book containing addresses
of full nodes that it can pick as primary and secondaries.  To obtain
a new header, the light client first does [verification](verification)
with the primary, and then cross-checks the header with the
secondaries using this specification.


### Tendermint Consensus and Forks



**TODO:** formalize the following

- The chain induces a sequence of NextV_i sets.
- Tendermint security model imposes correctness of >2/3 of each NextV_i
  for [Time_i, Time_i + trustingPeriod]
  
- If this assumption holds, consensus ensures that for each height, 
  there exists at most one block that is "properly signed"

Define "is supported" as containing >1/3 of the voting power of some
validator set

Define "is signed" as containing >2/3 of the voting power of the
"current" validator set

- if two distinct headers A and B both have height h, and A and B are supported
  by two validator sets within the trusting period, we call it a
  light fork.
 
- if two headers A and B both have height h, and there is a block at
  height h-1 within the trusting period such that its validator set
  signed A and B, we call it a fork on the main chain, or fork.
  
  
- a block that is not supported is called bogus (it can be generated
  just by faulty nodes within the tendermint security model)


### Informal Problem statement

> We put tags to informal problem statements as there is no sequential
> secification.

The following requirements are operational in that they describe how
things should be done, rather than what should be done. However, they
do not constitute temporal logic verification conditions. For those,
see [LCD-DIST-*] below.


#### **[LCD-IP-STATE]**

The detector works on a LightStore that contains LightBlocks in one of 
the state `StateUnverified`, ` StateVerified`, `StateFailed`, or
`StateTrusted`.


#### **[LCD-IP-Q]**

Whenever the light client verifier performs `VerifyToTarget` with the
primary and returns with
`(lightStore, ResultSuccess)`, the
 detector should query the secondaries by calling `FetchLightBlock` for height
 *LightStore.LatestVerified().Height* remotely.  
Then, 
the detector returns the set of all headers $h'$ downloaded from
secondaries that satisfy
 - *h'* is different from *LightStore.LatestVerified()*
 - *h'* is a (light) fork


#### **[LCD-IP-PEERSET]**

Whenever the detector observes misbehavior of a full node from the set
of Secondaries it should be replaced by a fresh full node.  (A full
node that has not been primary or secondary before). This includes in
particular the case where *h'* is different from
*LightStore.LatestVerified()* but h' is not a fork.




## Assumptions/Incentives/Environment

It is not in the interest of faulty full nodes to talk to the 
detector as long as the  detector is connected to at least one
correct full node. This would only increase the likelihood of
misbehavior being detected. Also we cannot punish them easily
(cheaply). The absence of a response need not be the fault of the full
node. 

Correct full nodes have the incentive to respond, because the 
detector may help them to understand whether their header is a good
one. We can thus base liveness arguments of the  detector on
the assumptions that correct full nodes reliably talk to the 
detector.


### Assumptions

#### **[LCD-A-CorrFull]**

At all times there is at least one correct full
node among the primary and the secondary.

**Remark:** Check whether [LCD-A-CorrFull] is not needed in the end because
the verification conditions [LCD-DIST-*] have preconditions on specific
cases where primary and/or secondaries are faulty.

#### **[LCD-A-RelComm]**

Communication between the  detector and a correct full node is 
reliable and bounded in time. Reliable communication means that
messages are not lost, not duplicated, and eventually delivered. There
is a (known) end-to-end delay *Delta*, such that if a message is sent
at time *t* then it is received and processes by time *t + Delta*.
This implies that we need a timeout of at least *2 Delta* for remote
procedure calls to ensure that the response of a correct peer arrives
before the timeout expires.




## (Distributed) Problem statement

> As the fork detector from the beginning is there to reduce the
> impact of faulty nodes, and faulty nodes imply that there is a
> distributed system, there is no sequential specification.

The  detector gets as input a lightstore *lightStore*.
Let *h-target = lightStore.LatestVerified().Height* and
     *h-trust=lightStore.LatestTrusted().Height* (see
     [LCV-DATA-LIGHTSTORE]).
It queries the secondaries for  headers at height *h-target*.
The  detector returns a set *Forks*, and should satisfy the following
     temporal formulas 


#### **[LCD-DIST-INV]**

If there is no fork at height *h-target*, then the detector should
return the empty set.


**TODO:** be precise about what a fork is. 

#### **[LCD-DIST-LIVE-FORK]**

If there is a fork at height *h*, with *h-trust < h <= h-target*, and
there are two correct full nodes *i* and *j* that are
  - on different branches, and
  - primary or secondary,

then the  detector eventually outputs the fork.

**TODO:** We can weaken the above to "the (not-necessarily correct)
primary provided branch A, and a correct secondary is on branch B". I
prefer the above as it is slightly less operational.


> #### **[LCD-REQ-REP]**
> If the  detector observes two conflicting headers for height *h*, 
> it should try to verify both. If both are verified it should report evidence.
> If the primary reports header *h* and a secondary reports header *h'*,
>     and if *h'* can be verified based on common root of trust, then
>     evidence should be generated; 
> By verifying we mean calling `VerifyToTarget` from the
> [[verification]] specification.

## Definitions

- A fixed set of full nodes is provided in the configuration upon
     initialization. Initially this set is partitioned into
    -  one full node that is the *primary* (singleton set),
	-  a set *Secondaries* (of fixed size, e.g., 3),
	-  a set *FullNodes*.
- A set *FaultyNodes* of nodes that the light client suspects of being faulty; it is initially empty

- *Lightstore* as defined in the [verification specification][verification].




#### **[LCD-INV-NODES]:**
The detector shall maintain the following invariants:
   - *FullNodes \intersect Secondaries = {}*
   - *FullNodes \intersect FaultyNodes = {}*
   - *Secondaries \intersect FaultyNodes = {}*
   
and the following transition invariant
   - *FullNodes' \union Secondaries' \union FaultyNodes' = FullNodes \union Secondaries \union FaultyNodes*

## Solution



### Inter Process Communication


```go
func FetchLightBlock(peer PeerID, height Height) LightBlock
```
See the [verification specification][verification] for details.

### Auxiliary Functions (Local)


```go
Replace_Secondary(addr Address)
```
- Expected precondition
    - *FullNodes* is nonempty
- Expected postcondition
    - addr is moved from *Secondaries* to *FaultyNodes*
    - an address *a* is moved from *FullNodes* to *Secondaries*
- Error condition
    - if precondition is violated



### From the verifier
```go
func VerifyToTarget(primary PeerID, lightStore LightStore,
                    targetHeight Height) (LightStore, Result)
```
See the [verification specification][verification] for details.



## Solution

Shared data of the light client
- a pool of full nodes *FullNodes* that have not been contacted before
- peer set called *Secondaries*
- primary
- LightStore




The problem is solved by calling  the function `ForkDetector` with
a lightstore that contains a light block that has
just been verified by the verifier. 


```go
func ForkDetector(ls LightStore)  {
    Forks.Init // initialize a container in which we collect forks
	for i, s range Secondaries {
		sh := FetchLightBlock(s,LightStore.LatestVerified().Height)
		// as the check below only needs the header, it is sufficient
		// to download the header rather than the LighBlock
		if LightStore.LatestVerified().Header == sh.Header {
				// header matches. we do nothing.
	    }
		else {
			    // [LCD-REQ-REP]
			    // header does not match. there is a situation.
				// we try to verify sh by querying s
				// we set up an auxiliary lightstore with the highest
			    // trusted lightblock and the lightblock we want to verify
				auxLS.Init
				auxLS.Update(LightStore.LatestTrusted(),StateVerified);
				auxLS.Update(sh,StateUnverified);
				result := VerifyToTarget(s, auxLS, LightStore.LatestVerified().Height)
				if result = (_,ResultSuccess) || (_,EXPIRED) {
				    // we verified header sh which is conflicting to hd
					// there is a fork on the main blockchain.
                    // If return code was EXPIRED it might be too late
			    	// to punish, we still report it.
					Forks.Add(sh)
				}
				else {
					// s might be faulty or unreachable
					Replace_peer(s)
					// If a new node is added to secondaries, this
					// should not imply an additional loop iteration.
					// We assume one of the secondaries is correct.
				}
			}
	}
	return (Forks,OK)
}
```

- Expected precondition
	- Secondaries initialized and non-empty
- Expected postcondition
    - satisfies [LCD-DIST-INV], [LCD-DIST-LIFE-FORK]
	- removes faulty secondary if it reports wrong header
- Error condition
    - fails if precondition is violated
	- fails if [LCV-INV-TP] is violated (no trusted header within
      trusting period




## Correctness arguments



#### Argument for [LCD-DIST-INV]

**TODO**


#### Argument for [LCD-DIST-LIFE-FORK]
**TODO**





# References

> links to other specifications/ADRs this document refers to


[[verification]] The specification of the light client verification.


[TMBC-FM-2THIRDS-linkVDD]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FM-2THIRDS-link]**:

[TMBC-FM-2THIRDS-link]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/verification.md


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md

[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md

[verificationVDD]: https://github.com/informalsystems/VDD/blob/master/lightclient/failuredetector.md

[verification]: https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/verification.md

[accountability]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md
