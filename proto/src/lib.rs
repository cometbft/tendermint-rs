//! tendermint-proto library gives the developer access to the Tendermint proto-defined structs.

// This module setup is necessary because the generated code contains "super::" calls for
// dependencies. Unfortunately, prost doesn't create this for us automatically.

#![deny(warnings, trivial_casts, trivial_numeric_casts, unused_import_braces)]
#![forbid(unsafe_code)]
#![doc(html_root_url = "https://docs.rs/tendermint-proto/0.17.0-rc2")]

// Built-in prost_types with slight customization to enable JSON-encoding
pub mod google {
    pub mod protobuf {
        include!("prost/google.protobuf.rs");
        // custom Timeout and Duration types that have valid doctest documentation texts
        include!("protobuf.rs");
    }
}

mod tendermint {
    pub mod abci {
        #![allow(clippy::large_enum_variant)]
        include!("prost/tendermint.abci.rs");
    }
    pub mod blockchain {
        #![allow(clippy::large_enum_variant)]
        include!("prost/tendermint.blockchain.rs");
    }
    pub mod consensus {
        include!("prost/tendermint.consensus.rs");
    }
    pub mod crypto {
        include!("prost/tendermint.crypto.rs");
    }
    pub mod evidence {
        include!("prost/tendermint.evidence.rs");
    }
    pub mod libs {
        pub mod bits {
            include!("prost/tendermint.libs.bits.rs");
        }
    }
    pub mod mempool {
        include!("prost/tendermint.mempool.rs");
    }
    pub mod p2p {
        include!("prost/tendermint.p2p.rs");
    }
    pub mod privval {
        include!("prost/tendermint.privval.rs");
    }
    pub mod rpc {
        pub mod grpc {
            include!("prost/tendermint.rpc.grpc.rs");
        }
    }
    pub mod state {
        include!("prost/tendermint.state.rs");
    }
    pub mod statesync {
        include!("prost/tendermint.statesync.rs");
    }
    pub mod store {
        include!("prost/tendermint.store.rs");
    }
    pub mod types {
        #![allow(clippy::large_enum_variant)]
        include!("prost/tendermint.types.rs");
    }
    pub mod version {
        include!("prost/tendermint.version.rs");
    }
}

pub use tendermint::*;

mod error;
use anomaly::BoxError;
use bytes::{Buf, BufMut};
pub use error::{Error, Kind};
use prost::encoding::encoded_len_varint;
use prost::Message;
use std::convert::{TryFrom, TryInto};

pub mod serializers;

/// Allows for easy Google Protocol Buffers encoding and decoding of domain
/// types with validation.
///
/// ## Examples
///
/// ```rust
/// use bytes::BufMut;
/// use prost::Message;
/// use std::convert::TryFrom;
/// use tendermint_proto::Protobuf;
///
/// // This struct would ordinarily be automatically generated by prost.
/// #[derive(Clone, PartialEq, Message)]
/// pub struct MyRawType {
///     #[prost(uint64, tag="1")]
///     pub a: u64,
///     #[prost(string, tag="2")]
///     pub b: String,
/// }
///
/// #[derive(Clone)]
/// pub struct MyDomainType {
///     a: u64,
///     b: String,
/// }
///
/// impl MyDomainType {
///     /// Trivial constructor with basic validation logic.
///     pub fn new(a: u64, b: String) -> Result<Self, String> {
///         if a < 1 {
///             return Err("a must be greater than 0".to_owned());
///         }
///         Ok(Self { a, b })
///     }
/// }
///
/// impl TryFrom<MyRawType> for MyDomainType {
///     type Error = String;
///
///     fn try_from(value: MyRawType) -> Result<Self, Self::Error> {
///         Self::new(value.a, value.b)
///     }
/// }
///
/// impl From<MyDomainType> for MyRawType {
///     fn from(value: MyDomainType) -> Self {
///         Self { a: value.a, b: value.b }
///     }
/// }
///
/// impl Protobuf<MyRawType> for MyDomainType {}
///
///
/// // Simulate an incoming valid raw message
/// let valid_raw = MyRawType { a: 1, b: "Hello!".to_owned() };
/// let mut valid_raw_bytes: Vec<u8> = Vec::new();
/// valid_raw.encode(&mut valid_raw_bytes).unwrap();
/// assert!(!valid_raw_bytes.is_empty());
///
/// // Try to decode the simulated incoming message
/// let valid_domain = MyDomainType::decode(valid_raw_bytes.clone().as_ref()).unwrap();
/// assert_eq!(1, valid_domain.a);
/// assert_eq!("Hello!".to_owned(), valid_domain.b);
///
/// // Encode it to compare the serialized form to what we received
/// let mut valid_domain_bytes: Vec<u8> = Vec::new();
/// valid_domain.encode(&mut valid_domain_bytes).unwrap();
/// assert_eq!(valid_raw_bytes, valid_domain_bytes);
///
/// // Simulate an incoming invalid raw message
/// let invalid_raw = MyRawType { a: 0, b: "Hello!".to_owned() };
/// let mut invalid_raw_bytes: Vec<u8> = Vec::new();
/// invalid_raw.encode(&mut invalid_raw_bytes).unwrap();
///
/// // We expect a validation error here
/// assert!(MyDomainType::decode(invalid_raw_bytes.as_ref()).is_err());
/// ```
pub trait Protobuf<T: Message + From<Self> + Default>
where
    Self: Sized + Clone + TryFrom<T>,
    <Self as TryFrom<T>>::Error: Into<BoxError>,
{
    /// Encodes the DomainType into a buffer.
    ///
    /// This function replaces the Prost::Message encode() function for DomainTypes.
    fn encode<B: BufMut>(&self, buf: &mut B) -> Result<(), Error> {
        T::from(self.clone())
            .encode(buf)
            .map_err(|e| Kind::EncodeMessage.context(e).into())
    }

    /// Encodes the DomainType with a length-delimiter to a buffer.
    ///
    /// An error will be returned if the buffer does not have sufficient capacity.
    ///
    /// This function replaces the Prost::Message encode_length_delimited() function for
    /// DomainTypes.
    fn encode_length_delimited<B: BufMut>(&self, buf: &mut B) -> Result<(), Error> {
        T::from(self.clone())
            .encode_length_delimited(buf)
            .map_err(|e| Kind::EncodeMessage.context(e).into())
    }

    /// Decodes an instance of the message from a buffer and then converts it into DomainType.
    ///
    /// The entire buffer will be consumed.
    ///
    /// This function replaces the Prost::Message decode() function for DomainTypes.
    fn decode<B: Buf>(buf: B) -> Result<Self, Error> {
        T::decode(buf).map_or_else(
            |e| Err(Kind::DecodeMessage.context(e).into()),
            |t| Self::try_from(t).map_err(|e| Kind::TryIntoDomainType.context(e).into()),
        )
    }

    /// Decodes a length-delimited instance of the message from the buffer.
    ///
    /// The entire buffer will be consumed.
    ///
    /// This function replaces the Prost::Message decode_length_delimited() function for
    /// DomainTypes.
    fn decode_length_delimited<B: Buf>(buf: B) -> Result<Self, Error> {
        T::decode_length_delimited(buf).map_or_else(
            |e| Err(Kind::DecodeMessage.context(e).into()),
            |t| Self::try_from(t).map_err(|e| Kind::TryIntoDomainType.context(e).into()),
        )
    }

    /// Returns the encoded length of the message without a length delimiter.
    ///
    /// This function replaces the Prost::Message encoded_len() function for DomainTypes.
    fn encoded_len(&self) -> usize {
        T::from(self.clone()).encoded_len()
    }

    /// Encodes the DomainType into a protobuf-encoded Vec<u8>
    fn encode_vec(&self) -> Result<Vec<u8>, Error> {
        let mut wire = Vec::with_capacity(self.encoded_len());
        self.encode(&mut wire).map(|_| wire)
    }

    /// Decodes a protobuf-encoded instance of the message from a Vec<u8> and then converts it into
    /// DomainType.
    fn decode_vec(v: &[u8]) -> Result<Self, Error> {
        Self::decode(v)
    }

    /// Encodes the DomainType with a length-delimiter to a Vec<u8> protobuf-encoded message.
    fn encode_length_delimited_vec(&self) -> Result<Vec<u8>, Error> {
        let len = self.encoded_len();
        let lenu64 = len.try_into().map_err(|e| Kind::EncodeMessage.context(e))?;
        let mut wire = Vec::with_capacity(len + encoded_len_varint(lenu64));
        self.encode_length_delimited(&mut wire).map(|_| wire)
    }

    /// Decodes a protobuf-encoded instance of the message with a length-delimiter from a Vec<u8>
    /// and then converts it into DomainType.
    fn decode_length_delimited_vec(v: &[u8]) -> Result<Self, Error> {
        Self::decode_length_delimited(v)
    }
}
